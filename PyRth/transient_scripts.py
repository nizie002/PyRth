# -*- coding: utf-8 -*-
"""
Created on Wed Dec 06 10:20:11 2017

@author: Nils Ziegeler
"""

import numpy as np
import os
import scipy.interpolate as ipl
import scipy.optimize as spo
import scipy.integrate as sin
import logging

from . import transient_utils as utl
from . import transient_optimization as top
from . import transient_defaults as dbase
from . import transient_core as core

logger = logging.getLogger("PyRthLogger")


class Evaluation:

    def __init__(self):
        self.parameters = {**dbase.std_eval_defaults, **dbase.std_output_defaults}
        self.figures = dict()

        self.modules = {}

        core.numba_preloader()
        logger.info("Evaluation instance initialized.")

    def save_all_figures(self, override_save: bool = False) -> None:
        """Save all figures generated by modules to PNG files.

        Args:
            override_save: Force save even if fig_save_on is False
        """
        if not (self.parameters["fig_save_on"] or override_save):
            return

        logger.info("Saving figures...")
        logger.debug(f"Number of figures to save: {len(self.figures)}")

        # Save each figure using its module's parameters
        for fig_name, fig_obj in self.figures.items():
            try:
                output_dir = self.parameters["output_dir"]
                os.makedirs(output_dir, exist_ok=True)

                filename = os.path.join(
                    output_dir, f"{fig_name}_{self.parameters['label']}.png"
                )
                fig_obj.fig.savefig(filename)
                fig_obj.close()
                logger.debug(f"Figure '{fig_name}' saved successfully.")

            except Exception as e:
                logger.error(f"Error saving figure '{fig_name}': {str(e)}")
                continue

    def modules_output(self):
        """Process output data for all modules based on their capabilities."""
        logger.info("Saving CSV files...")

        for key, module in self.modules.items():
            logger.debug(
                f"Processing output for Module {module.label} capabilities: {module.data_handlers}"
            )

            # Get list of available data handlers from module
            handlers = {
                "temp": module.temp_data_handler,
                "impedance": module.impedance_data_handler,
                "time_spec": module.time_spec_data_handler,
                "structure": module.structure_function_data_handler,
                "fft": module.fft_data_handler,
                "theo_structure": module.theo_structure_function_data_handler,
                "theo": module.theo_data_handler,
                "theo_compare": module.theo_compare_data_handler,
                "optimize": module.optimize_data_handler,
                "comparison": module.comparison_data_handler,
                "prediction": module.prediction_data_handler,
                "residual": module.residual_data_handler,
                "boot": module.boot_data_handler,
            }

            # Get module's capabilities (defined in module class)
            capabilities = getattr(module, "data_handlers", [])

            # Call each available handler
            for capability in capabilities:
                if capability in handlers:
                    logger.debug(f"Executing {capability} data handler")
                    try:
                        handlers[capability]()
                    except Exception as e:
                        logger.error(f"Error in {capability} data handler: {str(e)}")
                else:
                    logger.error(f"Handler {capability} not found")

    def standard_module(self, parameters):
        if not isinstance(parameters, dict):
            raise TypeError("Parameters must be provided as a dictionary.")

        self.parameters = dbase.validate_and_merge_defaults(parameters, self.parameters)

        module = self._standard_module(self.parameters)
        self._add_module_to_eval_dict(module)

        return [module]

    def _add_module_to_eval_dict(self, module):
        """Handle collision if module label already exists by adding incrementing counter."""
        if module.label in self.modules:
            original_label = module.label
            counter = 1
            while module.label in self.modules:
                module.label = f"{original_label}_{counter}"
                counter += 1
            logger.warning(
                f"Module label '{original_label}' already exists. Renamed to '{module.label}'."
            )
        self.modules[module.label] = module

    def _standard_module(self, parameters):

        module = core.Structure_function(parameters)

        # Ensure required parameters are set in the module
        if not hasattr(module, "label"):
            raise AttributeError(
                "Module is missing 'label' attribute. It is used to identify the results in CSV and image output."
            )
        if not hasattr(module, "conv_mode"):
            raise AttributeError(
                "Module is missing 'conv_mode' attribute. It is used for converting input data to the correct thermal impedance."
            )
        if not hasattr(module, "read_mode"):
            raise AttributeError(
                "Module is missing 'read_mode' attribute. It is used for reading input data in different formats."
            )

        if module.normalize_impedance_to_previous and hasattr(self, "stored_early_zth"):
            module.stored_early_zth = self.stored_early_zth

        module.figures = self.figures

        logger.info(f"Compiled impedance for '{module.label}'...")
        module.make_z()

        module.data_handlers.append("impedance")

        if not module.only_make_z:
            module.z_fit_deriv()
            logger.debug("Z fit derivative completed")
            logger.info(
                f"Current power is {abs(module.power_step - module.optical_power):.2f} W"
            )

            if not module.bayesian:
                logger.info("Performing Fourier transform...")
                module.fft_signal()
                module.fft_weight()
                module.time_spec()
                module.fft_data_handler()
                # Add FFT and time_spec handlers
                module.data_handlers.extend(["fft", "time_spec"])
            else:
                logger.info("Performing Bayesian deconvolution...")
                module.perform_bayesian_deconvolution()
                # Add time_spec handler for Bayesian
                module.data_handlers.append("time_spec")

            if module.calc_struc:
                logger.info(
                    f"Calculating structure function using {module.struc_method}"
                )
                module.foster_network()

                if module.struc_method == "polylong":
                    module.mpfr_foster_impedance()
                    module.poly_long_div()
                elif module.struc_method in ["khatwani", "sobhy"]:
                    module.mpfr_foster_impedance()
                    module.j_fraction_methods()
                elif module.struc_method == "boor_golub":
                    module.mpfr_foster_impedance()
                    module.boor_golub()
                elif module.struc_method == "lanczos":
                    module.lanczos()

                # Add structure handler after any structure calculation
                module.data_handlers.append("structure")

                logger.info(f"Total resistance: {module.int_cau_res[-1]:.2f} K/W")

        if module.normalize_impedance_to_previous and not hasattr(
            self, "stored_early_zth"
        ):
            self.stored_early_zth = utl.get_early_zth(module)

        return module

    def standard_module_set(self, parameters):

        if not isinstance(parameters, dict):
            raise TypeError("Parameters must be provided as a dictionary.")

        if "iterable_keywords" not in parameters:
            raise ValueError(
                "iterable_keywords must be provided in parameters. It is used to determine the keywords to iterate over."
            )

        if "evaluation_type" not in parameters:
            raise ValueError(
                "evaluation_type must be provided in parameters. It must be either 'standard' or 'optimization'. It is used to determine the type of evaluation to perform."
            )

        iterable_keywords = parameters.pop("iterable_keywords", [])
        evaluation_type = parameters.pop("evaluation_type", [])
        base_label = parameters.get("label", "")

        self.parameters = dbase.validate_and_merge_defaults(parameters, self.parameters)

        # Get the lists for each keyword and ensure they all have the same length
        lists = [parameters.get(keyword, []) for keyword in iterable_keywords]
        if not all(len(lst) == len(lists[0]) for lst in lists):
            raise ValueError("All iterable keyword lists must have the same length")

        modules_list = []
        for values in zip(*lists):
            # Create a copy of the parameters and update each keyword
            modified_parameters = parameters.copy()

            # Create unique label by appending values
            label_suffix = "_".join(
                f"{k}_{v}" for k, v in zip(iterable_keywords, values)
            )
            modified_parameters["label"] = f"{base_label}_{label_suffix}"

            for keyword, value in zip(iterable_keywords, values):
                modified_parameters[keyword] = value

            # Call the appropriate method with the modified parameters
            if evaluation_type == "standard":
                module = self._standard_evaluation(modified_parameters)
            elif evaluation_type == "optimization":
                module = self._optimization_evaluation(
                    modified_parameters, mode="from_asc"
                )
            else:
                raise ValueError(
                    "Invalid evaluation_type. Choose either 'standard' or 'optimization'."
                )

            modules_list.append(module)
            self.modules[module.label] = module

        print(f"Created {len(modules_list)} modules")
        print(f"First module: {modules_list[0].label}")
        print(f"Last module: {modules_list[-1].label}")

        print(f"First module: {self.modules[modules_list[0].label].label}")
        print(f"Last module: {self.modules[modules_list[-1].label].label}")

        return modules_list

    def bootstrap_module(self, parameters, mode=None):

        self.parameters = dbase.validate_and_merge_defaults(parameters, self.parameters)

        mode = self.parameters["bootstrap_mode"]

        if mode not in ["from_theo", "from_data", "given", "given_with_opt"]:
            raise ValueError(
                f"Invalid mode '{mode}' for bootstrap evaluation. Valid options are: ['from_theo', 'from_data', 'given', 'given_with_opt']"
            )
        repetitions = self.parameters["repetitions"]

        if not self.parameters["calc_struc"]:
            raise ValueError(
                "Structure function calculation must be enabled for bootstrapping."
            )

        if mode == "from_theo":
            module = self.theoretical_module(self.parameters)
            var = module.theo_impedance[-1] / self.parameters["signal_to_noise_ratio"]
            self.parameters["expected_var"] = var

        elif mode == "from_data":

            module = self._standard_module(self.parameters)

            module.hist, bin_edge = np.histogram(
                module.impedance - module.imp_smooth_full, bins=30
            )

            module.bins = (bin_edge[1:] + bin_edge[:-1]) / 2.0
            popt, pcov = spo.curve_fit(
                utl.generalized_gaussian, module.bins, module.hist, p0=(500, 0.1, 0.01)
            )

            module.gaus_curve = utl.generalized_gaussian(module.bins, *popt)

            module.data_handlers.append("residual")

        elif mode == "given" or mode == "given_with_opt":
            pass
        else:
            logger.error(f"Invalid mode for bootstrapping: {mode}")

        self.parameters["read_mode"] = "none"
        self.parameters["conv_mode"] = "none"

        logger.info(f"Bootstrapping: {repetitions} times")

        min_res = 1e100
        max_res = 1e-100

        # Set up the random number generator
        seed = self.parameters.get("random_seed")
        if seed is not None:
            rng = np.random.default_rng(seed)
        else:
            rng = np.random.default_rng()

        for n in range(repetitions):

            logger.info(f"Repetition {n + 1}...")

            if mode == "from_theo":
                self.parameters["impedance"] = module.theo_impedance + rng.normal(
                    0.0, var, len(module.theo_impedance)
                )
                self.parameters["time"] = np.exp(module.theo_log_time)
                (boot_module,) = self._standard_module(self.parameters)

                boot_module.reference_impedance = module.theo_impedance
                boot_module.reference_time_imp = module.theo_log_time
                boot_module.reference_deriv_time = module.theo_log_time
                boot_module.reference_derivative = module.theo_imp_deriv
                boot_module.reference_spectrum = module.theo_time_const
                boot_module.reference_sum_spectrum = sin.cumulative_trapezoid(
                    boot_module.reference_spectrum,
                    x=boot_module.reference_deriv_time,
                    initial=0.0,
                )
                boot_module.reference_cum_res = module.theo_int_cau_res
                boot_module.reference_cum_cap = module.theo_int_cau_cap

            elif mode == "from_data":

                self.parameters["expected_var"] = popt[1]
                self.parameters["impedance"] = module.imp_smooth_full + rng.normal(
                    0.0, abs(popt[1]), len(module.imp_smooth_full)
                )
                self.parameters["time"] = np.exp(module.log_time)

                (boot_module,) = self._standard_module(self.parameters)

                boot_module.reference_impedance = module.imp_smooth_full
                boot_module.reference_time_imp = module.log_time
                boot_module.reference_deriv_time = module.log_time_pad
                boot_module.reference_derivative = module.imp_deriv_interp
                boot_module.reference_spectrum = module.time_spec
                boot_module.reference_sum_spectrum = sin.cumulative_trapezoid(
                    boot_module.reference_spectrum,
                    x=boot_module.reference_deriv_time,
                    initial=0.0,
                )
                boot_module.reference_cum_res = module.int_cau_res
                boot_module.reference_cum_cap = module.int_cau_cap

            elif mode == "given":
                var = (
                    self.parameters["impedance_no_noise"][-1]
                    / self.parameters["signal_to_noise_ratio"]
                )
                self.parameters["expected_var"] = var
                self.parameters["impedance"] = self.parameters[
                    "impedance_no_noise"
                ] + rng.normal(0.0, var, len(self.parameters["impedance_no_noise"]))

                (boot_module,) = self._standard_module(self.parameters)

                boot_module.reference_time_imp = np.log(self.parameters["time"])
                boot_module.reference_impedance = self.parameters["impedance_no_noise"]
                boot_module.reference_deriv_time = self.parameters[
                    "reference_deriv_time"
                ]
                boot_module.reference_derivative = self.parameters[
                    "reference_derivative"
                ]
                boot_module.reference_spectrum = self.parameters["reference_spectrum"]
                boot_module.reference_sum_spectrum = sin.cumulative_trapezoid(
                    self.parameters["reference_spectrum"],
                    x=boot_module.reference_deriv_time,
                    initial=0.0,
                )
                boot_module.reference_cum_res = self.parameters["reference_cum_res"]
                boot_module.reference_cum_cap = self.parameters["reference_cum_cap"]

            elif mode == "given_with_opt":
                var = (
                    self.parameters["impedance_no_noise"][-1]
                    / self.parameters["signal_to_noise_ratio"]
                )
                self.parameters["expected_var"] = var
                self.parameters["impedance"] = self.parameters[
                    "impedance_no_noise"
                ] + rng.normal(0.0, var, len(self.parameters["impedance_no_noise"]))

                boot_module = self.optimization_module({}, mode="from_internal")

                boot_module.reference_time_imp = np.log(self.parameters["time"])
                boot_module.reference_impedance = self.parameters["impedance_no_noise"]
                boot_module.reference_deriv_time = self.parameters[
                    "reference_deriv_time"
                ]
                boot_module.reference_derivative = self.parameters[
                    "reference_derivative"
                ]
                boot_module.reference_spectrum = self.parameters["reference_spectrum"]
                boot_module.reference_sum_spectrum = sin.cumulative_trapezoid(
                    self.parameters["reference_spectrum"],
                    x=boot_module.reference_deriv_time,
                    initial=0.0,
                )
                boot_module.reference_cum_res = self.parameters["reference_cum_res"]
                boot_module.reference_cum_cap = self.parameters["reference_cum_cap"]
            else:
                logger.error("Invalid mode for bootstrapping")

            if mode == "from_theo" or mode == "from_data" or mode == "given":

                if n == 0:
                    self.imp_time = boot_module.log_time
                    self.deriv_time = boot_module.log_time_pad
                    self.results_imp = np.zeros(
                        (repetitions, len(boot_module.impedance))
                    )
                    self.results_deriv = np.zeros(
                        (repetitions, len(boot_module.imp_deriv_interp))
                    )
                    self.results_timeconst = np.zeros(
                        (repetitions, len(boot_module.time_spec))
                    )
                    self.results_sum_timeconst = np.zeros(
                        (repetitions, len(boot_module.time_spec))
                    )
                    self.results_struc_res = [0] * repetitions
                    self.results_struc_cap = [0] * repetitions

                self.results_imp[n, :] = boot_module.impedance.flatten()
                self.results_deriv[n, :] = boot_module.imp_deriv_interp.flatten()
                self.results_timeconst[n, :] = boot_module.time_spec.flatten()
                self.results_sum_timeconst[n, :] = sin.cumulative_trapezoid(
                    boot_module.time_spec.flatten(),
                    x=boot_module.log_time_pad,
                    initial=0.0,
                )
                self.results_struc_res[n] = boot_module.int_cau_res.flatten()
                self.results_struc_cap[n] = boot_module.int_cau_cap.flatten()

            elif mode == "given_with_opt":

                if n == 0:
                    self.imp_time = boot_module.theo_log_time
                    self.deriv_time = boot_module.theo_log_time
                    self.results_imp = np.zeros(
                        (repetitions, len(boot_module.theo_impedance))
                    )
                    self.results_deriv = np.zeros(
                        (repetitions, len(boot_module.theo_imp_deriv))
                    )
                    self.results_timeconst = np.zeros(
                        (repetitions, len(boot_module.theo_time_const))
                    )
                    self.results_sum_timeconst = np.zeros(
                        (repetitions, len(boot_module.theo_time_const))
                    )
                    self.results_struc_res = [0] * repetitions
                    self.results_struc_cap = [0] * repetitions

                self.results_imp[n, :] = boot_module.theo_impedance.flatten()
                self.results_deriv[n, :] = boot_module.theo_imp_deriv.flatten()
                self.results_timeconst[n, :] = boot_module.theo_time_const.flatten()
                self.results_sum_timeconst[n, :] = sin.cumulative_trapezoid(
                    boot_module.theo_time_const.flatten(),
                    x=boot_module.theo_log_time,
                    initial=0.0,
                )
                self.results_struc_res[n] = boot_module.theo_int_cau_res.flatten()
                self.results_struc_cap[n] = boot_module.theo_int_cau_cap.flatten()
            else:
                logger.error(f"Invalid mode for bootstrapping: {mode}")

            if self.results_struc_res[n][0] < min_res:
                min_res = self.results_struc_res[n][0]
            if self.results_struc_res[n][-1] > max_res:
                max_res = self.results_struc_res[n][-1]
                if max_res > 150:
                    max_res = 150

            logger.info("Done")
        logger.info("Calculating confidence intervals...")

        boot_module.imp_time = self.imp_time
        boot_module.deriv_time = self.deriv_time

        boot_module.imp_av = np.median(self.results_imp, axis=0)
        boot_module.imp_perc_u, boot_module.imp_perc_l = np.percentile(
            self.results_imp, [10, 90], axis=0
        )

        boot_module.deriv_av = np.median(self.results_deriv, axis=0)
        boot_module.deriv_perc_u, boot_module.deriv_perc_l = np.percentile(
            self.results_deriv, [10, 90], axis=0
        )

        boot_module.time_spec_av = np.median(self.results_timeconst, axis=0)
        boot_module.time_spec_perc_u, boot_module.time_spec_perc_l = np.percentile(
            self.results_timeconst, [10, 90], axis=0
        )

        boot_module.sum_time_spec_av = np.median(self.results_sum_timeconst, axis=0)
        boot_module.sum_time_spec_perc_u, boot_module.sum_time_spec_perc_l = (
            np.percentile(self.results_sum_timeconst, [10, 90], axis=0)
        )

        base_num_coarse = int(1e3)
        base_num_fine = int(1e5)

        x_num_coarse = int(
            base_num_coarse * ((max_res - min_res) / boot_module.reference_cum_res[-1])
        )
        boot_module.imp_z_coarse = np.linspace(
            boot_module.imp_time[0], boot_module.imp_time[-1], base_num_coarse
        )

        boot_module.imp_av_coarse = np.interp(
            boot_module.imp_z_coarse, boot_module.imp_time, boot_module.imp_av
        )
        boot_module.imp_perc_u_coarse = np.interp(
            boot_module.imp_z_coarse, boot_module.imp_time, boot_module.imp_perc_u
        )
        boot_module.imp_perc_l_coarse = np.interp(
            boot_module.imp_z_coarse, boot_module.imp_time, boot_module.imp_perc_l
        )

        boot_module.res_coarse = np.linspace(
            min_res, max_res, x_num_coarse, endpoint=True
        )
        boot_module.res_fine = np.linspace(
            min_res, max_res, base_num_fine, endpoint=True
        )

        interp_func = [0] * repetitions
        for n in range(repetitions):
            interp_func[n] = ipl.interp1d(
                self.results_struc_res[n], self.results_struc_cap[n]
            )

        boot_module.struc_cap_av = np.zeros(base_num_fine)
        boot_module.struc_cap_perc_u = np.zeros(base_num_fine)
        boot_module.struc_cap_perc_l = np.zeros(base_num_fine)

        N_res = -1
        for res in boot_module.res_fine:
            N_res += 1
            N = 0
            vals = [0.0] * repetitions
            for m in range(repetitions):
                if res > self.results_struc_res[m][-1]:
                    vals[N] = self.results_struc_cap[m][-1]
                    N += 1
                elif (res >= self.results_struc_res[m][0]) and (
                    res <= self.results_struc_res[m][-1]
                ):
                    vals[N] = interp_func[m](res)
                    N += 1

            boot_module.struc_cap_av[N_res] = np.median(vals[:N])
            boot_module.struc_cap_perc_u[N_res], boot_module.struc_cap_perc_l[N_res] = (
                np.percentile(vals[:N], [10, 90])
            )

        boot_module.struc_cap_av_coarse = np.interp(
            boot_module.res_coarse, boot_module.res_fine, boot_module.struc_cap_av
        )
        boot_module.struc_cap_perc_u_coarse = np.interp(
            boot_module.res_coarse, boot_module.res_fine, boot_module.struc_cap_perc_u
        )
        boot_module.struc_cap_perc_l_coarse = np.interp(
            boot_module.res_coarse, boot_module.res_fine, boot_module.struc_cap_perc_l
        )

        dex_coarse = np.searchsorted(boot_module.struc_cap_av_coarse, 1e6) + 1
        dex = np.searchsorted(boot_module.struc_cap_av, 1e6) + 1

        boot_module.res_fine = boot_module.res_fine[:dex]
        boot_module.struc_cap_av = boot_module.struc_cap_av[:dex]
        boot_module.struc_cap_perc_u = boot_module.struc_cap_perc_u[:dex]
        boot_module.struc_cap_perc_l = boot_module.struc_cap_perc_l[:dex]

        boot_module.res_coarse = boot_module.res_coarse[:dex_coarse]
        boot_module.struc_cap_av_coarse = boot_module.struc_cap_av_coarse[:dex_coarse]
        boot_module.struc_cap_perc_u_coarse = boot_module.struc_cap_perc_u_coarse[
            :dex_coarse
        ]
        boot_module.struc_cap_perc_l_coarse = boot_module.struc_cap_perc_l_coarse[
            :dex_coarse
        ]

        logger.info("Ok")

        boot_module.data_handlers.append("boot")

        self._add_module_to_eval_dict(boot_module)
        return boot_module

    def optimization_module(self, parameters):
        if not isinstance(parameters, dict):
            raise TypeError("Parameters must be provided as a dictionary.")

        mode = parameters.pop("mode", "from_asc")

        self.parameters = dbase.validate_and_merge_defaults(parameters, self.parameters)

        module = self._optimization_module(parameters, mode=mode)

        self._add_module_to_eval_dict(module)

        return module

    def _optimization_module(self, parameters, mode="from_asc", external_module=None):

        if mode == "from_asc":
            module = self._standard_module(self.parameters)
            module.theo_log_time = np.linspace(
                self.parameters["theo_log_time"][0],
                self.parameters["theo_log_time"][1],
                self.parameters["theo_log_time_size"],
            )

            if module.opt_extrapolate == True:

                module.opt_log_time = module.log_time[
                    module.fit_add + module.lower_fit_limit :
                ]
                module.opt_imp = module.impedance[
                    module.fit_add + module.lower_fit_limit :
                ]

            elif module.opt_extrapolate == False:
                module.opt_log_time = module.log_time
                module.opt_imp = module.impedance

            module.cau_res_opt = module.int_cau_res
            module.cau_cap_opt = module.int_cau_cap

        if mode == "from_external" or mode == "from_internal":

            self.parameters["read_mode"] = "none"
            self.parameters["conv_mode"] = "none"

            module = self._standard_module(self.parameters)

            module.cau_res_opt = module.int_cau_res
            module.cau_cap_opt = module.int_cau_cap

            if mode == "from_external":

                module.theo_log_time = np.linspace(
                    external_module.theo_log_time[0],
                    external_module.theo_log_time[-1],
                    self.parameters["theo_log_time_size"],
                )

                module.opt_log_time = module.log_time

                module.opt_imp = self.parameters["impedance"]

            if mode == "from_internal":

                module.theo_log_time = np.linspace(
                    self.parameters["theo_log_time"][0],
                    self.parameters["theo_log_time"][1],
                    self.parameters["theo_log_time_size"],
                )

                module.opt_log_time = module.log_time

                module.opt_imp = self.parameters["impedance"]

        N = self.parameters["opt_model_layers"]
        theo_lengths = [1] * N
        if self.parameters["struc_init_method"] == "optimal_fit":
            logger.info("Optimizing structure function approximation...")

            struc_marker, init_opt_result = top.optimize_theo_struc(
                module.cau_res_opt, module.cau_cap_opt, N
            )
            (
                module.init_opt_imp_res,
                module.init_opt_imp_cap,
                module.init_opt_struc_res,
                module.init_opt_struc_cap,
            ) = struc_marker

            logger.info("Optimization done")
            logger.info(
                f"Message: {init_opt_result.message}, Success: {init_opt_result.success}"
            )

        if self.parameters["struc_init_method"] == "x_sampling":

            module.init_opt_imp_res, module.init_opt_imp_cap = top.struc_x_sample(
                module.cau_res_opt, module.cau_cap_opt, N
            )

        module.init_opt_imp_res_diff = top.sort_and_lim_diff(module.init_opt_imp_res)
        module.init_opt_imp_cap_diff = top.sort_and_lim_diff(module.init_opt_imp_cap)

        logger.info("Optimizing structure function to impedance...")

        global_weight = np.append(
            (module.opt_log_time[1:] - module.opt_log_time[:-1]),
            (module.opt_log_time[-1] - module.opt_log_time[-2]),
        )

        global_weight = global_weight / np.average(global_weight)

        module.fin_res, module.fin_cap, opt_result = top.optimize_to_imp(
            module.init_opt_imp_res,
            module.init_opt_imp_cap,
            module.theo_log_time,
            module.opt_imp,
            module.opt_log_time,
            global_weight,
            self.parameters["theo_delta"],
            self.parameters["opt_method"],
        )

        logger.info("Optimization done")
        logger.info(f"Message: {opt_result.message}, Success: {opt_result.success}")

        logger.info("Showing result...")

        module.fin_res_diff = top.sort_and_lim_diff(module.fin_res)
        module.fin_cap_diff = top.sort_and_lim_diff(module.fin_cap)

        print(module.fin_res_diff, module.fin_cap_diff)

        module.theo_int_cau_res, module.theo_int_cau_cap = top.struc_params_to_func(
            1000, theo_lengths, module.fin_res_diff, module.fin_cap_diff
        )

        module.theo_diff_struc = np.zeros(len(module.theo_int_cau_res) - 1)
        for i in range(len(module.theo_int_cau_res) - 1):
            if not (module.theo_int_cau_res[i] - module.theo_int_cau_res[i + 1]) == 0.0:
                module.theo_diff_struc[i] = (
                    module.theo_int_cau_cap[i] - module.theo_int_cau_cap[i + 1]
                ) / (module.theo_int_cau_res[i] - module.theo_int_cau_res[i + 1])

        module.theo_time_const = top.struc_to_time_const(
            module.theo_log_time,
            self.parameters["theo_delta"],
            theo_lengths,
            module.fin_res_diff,
            module.fin_cap_diff,
        )

        module.theo_imp_deriv, module.theo_impedance = top.time_const_to_imp(
            module.theo_log_time, module.theo_time_const
        )

        module.init_theo_time_const = top.struc_to_time_const(
            module.theo_log_time,
            self.parameters["theo_delta"],
            theo_lengths,
            module.init_opt_imp_res_diff,
            module.init_opt_imp_cap_diff,
        )

        module.init_theo_imp_deriv, module.init_theo_impedance = top.time_const_to_imp(
            module.theo_log_time, module.init_theo_time_const
        )

        module.back_imp_deriv, module.back_imp = top.time_const_to_imp(
            module.log_time_pad, module.time_spec
        )

        init_theo_impedance_int = np.interp(
            module.opt_log_time, module.theo_log_time, module.init_theo_impedance
        )
        theo_impedance_int = np.interp(
            module.opt_log_time, module.theo_log_time, module.theo_impedance
        )
        back_imp_int = np.interp(
            module.opt_log_time, module.log_time_pad, module.back_imp
        )

        logger.info("Done")

        module.data_handlers.append("theo_structure")
        module.data_handlers.append("theo")
        module.data_handlers.append("theo_compare")
        module.data_handlers.append("optimize")

        logger.info(
            "initial diff:",
            top.weighted_diff(
                module.opt_log_time, module.opt_imp, init_theo_impedance_int
            ),
        )
        logger.info(
            "forward diff:",
            top.weighted_diff(module.opt_log_time, module.opt_imp, back_imp_int),
        )
        logger.info(
            "optimi. diff:",
            top.weighted_diff(module.opt_log_time, module.opt_imp, theo_impedance_int),
        )

        return module

    def theoretical_module(self, parameters):

        self.parameters = {
            **dbase.std_eval_defaults,
            **dbase.std_output_defaults,
            **parameters,
        }

        module = core.Structure_function(self.parameters)
        module.figures = self.figures

        module.theo_log_time = np.linspace(
            self.parameters["theo_log_time"][0],
            self.parameters["theo_log_time"][1],
            self.parameters["theo_log_time_size"],
        )
        module.theo_delta = self.parameters["theo_delta"]

        module.theo_lengths = self.parameters["theo_lengths"]
        module.theo_resistances = self.parameters["theo_resistances"]
        module.theo_capacitances = self.parameters["theo_capacitances"]

        module.theo_int_cau_res, module.theo_int_cau_cap = top.struc_params_to_func(
            1000, module.theo_lengths, module.theo_resistances, module.theo_capacitances
        )

        module.theo_int_cau_res = module.theo_int_cau_res[1:]
        module.theo_int_cau_cap = module.theo_int_cau_cap[1:]

        module.theo_diff_struc = np.zeros(len(module.theo_int_cau_res) - 1)
        for i in range(len(module.theo_int_cau_res) - 1):
            if not (module.theo_int_cau_res[i] - module.theo_int_cau_res[i + 1]) == 0.0:
                module.theo_diff_struc[i] = (
                    module.theo_int_cau_cap[i] - module.theo_int_cau_cap[i + 1]
                ) / (module.theo_int_cau_res[i] - module.theo_int_cau_res[i + 1])

        module.theo_time_const = top.struc_to_time_const(
            module.theo_log_time,
            module.theo_delta,
            module.theo_lengths,
            module.theo_resistances,
            module.theo_capacitances,
        )

        module.theo_imp_deriv, module.theo_impedance = top.time_const_to_imp(
            module.theo_log_time, module.theo_time_const
        )

        self._add_module_to_eval_dict(module)

        module.data_handlers.append("theo_structure")
        module.data_handlers.append("theo")

        return [module]

    def comparison_module(self, parameters, modifier):

        for key, value in parameters.items():
            self.parameters[key] = value

        label_base = modifier["label"]
        self.parameters["label"] = label_base + "theo_ideal"

        if not modifier["mod_method"] == "measure_opt":
            theo_module = self.theoretical_module({})

        self.parameters["look_at_backwards_imp_deriv"] = False
        self.parameters["look_at_backwards_impedance"] = False
        self.parameters["look_at_temp"] = False

        for key, value in modifier.items():
            self.parameters[key] = value

        if type(modifier["mod_key"]) is tuple:
            m = len(modifier["mod_value"][0])
            self.parameters["mod_value_list"] = modifier["mod_value"][0]
            self.parameters["mod_key_display_name"] = modifier["mod_key"][0]
        else:
            m = len(modifier["mod_value"])
            self.parameters["mod_value_list"] = modifier["mod_value"]
            self.parameters["mod_key_display_name"] = modifier["mod_key"]

        self.parameters["fig_total_calls"] = m

        self.parameters["read_mode"] = "none"
        self.parameters["conv_mode"] = "none"
        self.parameters["time_const_comparison"] = [0] * m
        self.parameters["structure_comparison"] = [0] * m
        self.parameters["total_resist_diff"] = [0] * m

        logger.info(f"Comparing: {self.parameters['label']}")

        for n in range(m):

            if type(modifier["mod_key"]) is tuple:
                tuplen = len(modifier["mod_key"])
                self.parameters["label"] = label_base
                for tup in range(tuplen):
                    logger.info(
                        f"{n+1}/{m}, parameter {modifier['mod_key'][tup]} set to {modifier['mod_value'][tup][n]}..."
                    )
                    self.parameters[modifier["mod_key"][tup]] = modifier["mod_value"][
                        tup
                    ][n]

                    self.parameters["label"] = (
                        self.parameters["label"]
                        + modifier["mod_key"][tup]
                        + "_"
                        + str(modifier["mod_value"][tup][n]).replace(".", "")
                    )
            else:
                logger.info(
                    f"{n+1}/{m}, parameter {modifier['mod_key']} set to {modifier['mod_value'][n]}..."
                )
                self.parameters[modifier["mod_key"]] = modifier["mod_value"][n]

                self.parameters["label"] = (
                    label_base
                    + modifier["mod_key"]
                    + "_"
                    + str(modifier["mod_value"][n]).replace(".", "")
                )

            if modifier["mod_method"] == "theoretical":

                comp_module = self.theoretical_module({})

                print("end impedance", comp_module.theo_impedance[-1])

                comp_module.time_const_comparison[n] = top.l2_norm_time_const(
                    theo_module.theo_log_time,
                    theo_module.theo_time_const,
                    comp_module.theo_log_time,
                    comp_module.theo_time_const,
                )
                comp_module.structure_comparison[n] = top.norm_structure(
                    theo_module.theo_int_cau_res,
                    theo_module.theo_int_cau_cap,
                    comp_module.theo_int_cau_res,
                    comp_module.theo_int_cau_cap,
                )
                comp_module.total_resist_diff[n] = np.abs(
                    comp_module.theo_int_cau_res[-1] - theo_module.theo_int_cau_res[-1]
                )

            if modifier["mod_method"] == "measure_opt":

                self.parameters["read_mode"] = parameters["read_mode"]
                self.parameters["conv_mode"] = parameters["conv_mode"]

                comp_module = self._optimization_module(
                    self.parameters, mode="from_asc"
                )

                comp_module.time_const_comparison[n] = 1.0
                comp_module.structure_comparison[n] = 1.0
                comp_module.total_resist_diff[n] = 1.0

            if modifier["mod_method"] == "forward":

                self.parameters["expected_var"] = 0.0
                self.parameters["impedance"] = theo_module.impedance
                self.parameters["time"] = np.exp(theo_module.log_time)

                comp_module = self._standard_module(self.parameters)

                comp_module.time_const_comparison[n] = top.l2_norm_time_const(
                    theo_module.theo_log_time,
                    theo_module.theo_time_const,
                    comp_module.log_time_pad,
                    comp_module.time_spec,
                )
                comp_module.structure_comparison[n] = top.norm_structure(
                    theo_module.theo_int_cau_res,
                    theo_module.theo_int_cau_cap,
                    comp_module.int_cau_res,
                    comp_module.int_cau_cap,
                )
                comp_module.total_resist_diff[n] = np.abs(
                    comp_module.int_cau_res[-1] - theo_module.theo_int_cau_res[-1]
                )

            elif modifier["mod_method"] == "optimization":

                self.parameters["expected_var"] = 0.0
                self.parameters["impedance"] = theo_module.impedance
                self.parameters["time"] = np.exp(theo_module.log_time)

                comp_module = self._optimization_module(
                    {}, mode="from_external", external_module=theo_module
                )

                comp_module.time_const_comparison[n] = top.l2_norm_time_const(
                    theo_module.theo_log_time,
                    theo_module.theo_time_const,
                    comp_module.theo_log_time,
                    comp_module.theo_time_const,
                )
                comp_module.structure_comparison[n] = top.norm_structure(
                    theo_module.theo_int_cau_res,
                    theo_module.theo_int_cau_cap,
                    comp_module.theo_int_cau_res,
                    comp_module.theo_int_cau_cap,
                )
                comp_module.total_resist_diff[n] = np.abs(
                    comp_module.theo_int_cau_res[-1] - theo_module.theo_int_cau_res[-1]
                )

            elif modifier["mod_method"] == "forward_with_noise":

                coarse_num = int(1e4)

                log_time_coarse = np.linspace(
                    theo_module.log_time[0], theo_module.log_time[-1], coarse_num
                )

                self.parameters["impedance_no_noise"] = np.interp(
                    log_time_coarse, theo_module.log_time, theo_module.impedance
                )
                self.parameters["time"] = np.exp(log_time_coarse)
                self.parameters["reference_deriv_time"] = theo_module.theo_log_time
                self.parameters["reference_derivative"] = theo_module.theo_imp_deriv
                self.parameters["reference_spectrum"] = theo_module.theo_time_const
                self.parameters["reference_cum_res"] = theo_module.theo_int_cau_res
                self.parameters["reference_cum_cap"] = theo_module.theo_int_cau_cap

                comp_module = self.bootstrap_module({}, mode="given")

                comp_module.time_const_comparison[n] = top.l2_norm_time_const(
                    theo_module.theo_log_time,
                    theo_module.theo_time_const,
                    comp_module.log_time_pad,
                    comp_module.sum_time_spec_av,
                    sum_given=True,
                )
                comp_module.structure_comparison[n] = top.norm_structure(
                    theo_module.theo_int_cau_res,
                    theo_module.theo_int_cau_cap,
                    comp_module.res_fine,
                    comp_module.struc_cap_av,
                )

                dex = np.searchsorted(comp_module.struc_cap_av, 1e10) - 1
                comp_module.total_resist_diff[n] = np.abs(
                    comp_module.res_fine[dex] - theo_module.theo_int_cau_res[-1]
                )

            elif modifier["mod_method"] == "optimization_with_noise":

                coarse_num = int(1e4)

                log_time_coarse = np.linspace(
                    theo_module.log_time[0], theo_module.log_time[-1], coarse_num
                )

                self.parameters["impedance_no_noise"] = np.interp(
                    log_time_coarse, theo_module.log_time, theo_module.impedance
                )
                self.parameters["time"] = np.exp(log_time_coarse)
                self.parameters["reference_deriv_time"] = theo_module.theo_log_time
                self.parameters["reference_derivative"] = theo_module.theo_imp_deriv
                self.parameters["reference_spectrum"] = theo_module.theo_time_const
                self.parameters["reference_cum_res"] = theo_module.theo_int_cau_res
                self.parameters["reference_cum_cap"] = theo_module.theo_int_cau_cap

                comp_module = self.bootstrap_module({}, mode="given_with_opt")

                comp_module.time_const_comparison[n] = top.l2_norm_time_const(
                    theo_module.theo_log_time,
                    theo_module.theo_time_const,
                    comp_module.deriv_time,
                    comp_module.sum_time_spec_av,
                    sum_given=True,
                )
                comp_module.structure_comparison[n] = top.norm_structure(
                    theo_module.theo_int_cau_res,
                    theo_module.theo_int_cau_cap,
                    comp_module.res_fine,
                    comp_module.struc_cap_av,
                )

                comp_module.total_resist_diff[n] = np.abs(
                    comp_module.theo_int_cau_res[-1] - theo_module.theo_int_cau_res[-1]
                )

            elif modifier["mod_method"] == "forward_with_noise_sparse":

                maxrate = 1e-7
                log_frac = 0.3

                start = theo_module.log_time[0]
                stop = theo_module.log_time[-1]
                delta = stop - start

                log_time_coarse_lin_1, step = np.linspace(
                    np.exp(start),
                    np.exp(start + log_frac * delta),
                    int((np.exp(start + log_frac * delta) - np.exp(start)) / maxrate),
                    endpoint=False,
                    retstep=True,
                )

                log_step = np.log(log_time_coarse_lin_1[-1]) - np.log(
                    log_time_coarse_lin_1[-2]
                )

                log_time_coarse_lin_2 = np.exp(
                    np.linspace(
                        start + log_frac * delta,
                        stop,
                        int((stop - (start + log_frac * delta)) / log_step),
                    )
                )

                log_time_coarse_lin = np.concatenate(
                    (log_time_coarse_lin_1, log_time_coarse_lin_2)
                )

                print(
                    step,
                    log_step,
                    len(log_time_coarse_lin_1),
                    len(log_time_coarse_lin_2),
                )

                log_time_coarse = np.log(log_time_coarse_lin)

                self.parameters["impedance_no_noise"] = np.interp(
                    log_time_coarse, theo_module.log_time, theo_module.impedance
                )
                self.parameters["time"] = np.exp(log_time_coarse)
                self.parameters["reference_deriv_time"] = theo_module.theo_log_time
                self.parameters["reference_derivative"] = theo_module.theo_imp_deriv
                self.parameters["reference_spectrum"] = theo_module.theo_time_const
                self.parameters["reference_cum_res"] = theo_module.theo_int_cau_res
                self.parameters["reference_cum_cap"] = theo_module.theo_int_cau_cap

                comp_module = self.bootstrap_module({}, mode="given")

                comp_module.time_const_comparison[n] = top.l2_norm_time_const(
                    theo_module.theo_log_time,
                    theo_module.theo_time_const,
                    comp_module.log_time_pad,
                    comp_module.sum_time_spec_av,
                    sum_given=True,
                )
                comp_module.structure_comparison[n] = top.norm_structure(
                    theo_module.theo_int_cau_res,
                    theo_module.theo_int_cau_cap,
                    comp_module.res_fine,
                    comp_module.struc_cap_av,
                )

                dex = np.searchsorted(comp_module.struc_cap_av, 1e10) - 1
                comp_module.total_resist_diff[n] = np.abs(
                    comp_module.res_fine[dex] - theo_module.theo_int_cau_res[-1]
                )

            elif modifier["mod_method"] == "optimization_with_noise_sparse":

                maxrate = 1e-7
                log_frac = 0.3

                start = theo_module.log_time[0]
                stop = theo_module.log_time[-1]
                delta = stop - start

                log_time_coarse_lin_1, step = np.linspace(
                    np.exp(start),
                    np.exp(start + log_frac * delta),
                    int((np.exp(start + log_frac * delta) - np.exp(start)) / maxrate),
                    endpoint=False,
                    retstep=True,
                )

                log_step = np.log(log_time_coarse_lin_1[-1]) - np.log(
                    log_time_coarse_lin_1[-2]
                )

                log_time_coarse_lin_2 = np.exp(
                    np.linspace(
                        start + log_frac * delta,
                        stop,
                        int((stop - (start + log_frac * delta)) / log_step),
                    )
                )

                log_time_coarse_lin = np.concatenate(
                    (log_time_coarse_lin_1, log_time_coarse_lin_2)
                )

                print(
                    step,
                    log_step,
                    len(log_time_coarse_lin_1),
                    len(log_time_coarse_lin_2),
                )

                log_time_coarse = np.log(log_time_coarse_lin)

                self.parameters["impedance_no_noise"] = np.interp(
                    log_time_coarse, theo_module.log_time, theo_module.impedance
                )
                self.parameters["time"] = np.exp(log_time_coarse)
                self.parameters["reference_deriv_time"] = theo_module.theo_log_time
                self.parameters["reference_derivative"] = theo_module.theo_imp_deriv
                self.parameters["reference_spectrum"] = theo_module.theo_time_const
                self.parameters["reference_cum_res"] = theo_module.theo_int_cau_res
                self.parameters["reference_cum_cap"] = theo_module.theo_int_cau_cap

                comp_module = self.bootstrap_module({}, mode="given_with_opt")

                comp_module.time_const_comparison[n] = top.l2_norm_time_const(
                    theo_module.theo_log_time,
                    theo_module.theo_time_const,
                    comp_module.deriv_time,
                    comp_module.sum_time_spec_av,
                    sum_given=True,
                )
                comp_module.structure_comparison[n] = top.norm_structure(
                    theo_module.theo_int_cau_res,
                    theo_module.theo_int_cau_cap,
                    comp_module.res_fine,
                    comp_module.struc_cap_av,
                )

                comp_module.total_resist_diff[n] = np.abs(
                    comp_module.theo_int_cau_res[-1] - theo_module.theo_int_cau_res[-1]
                )

            logger.info(f"l2_norm_time_const: {comp_module.time_const_comparison[n]}")
            logger.info(f"norm_structure: {comp_module.structure_comparison[n]}")
            logger.info(f"total_resist_diff: {comp_module.total_resist_diff[n]}")
            logger.info("Done")

        if type(modifier["mod_key"]) is tuple:
            comp_module.label = label_base
            for tup in range(tuplen):
                comp_module.label = comp_module.label + modifier["mod_key"][tup] + "_"

        else:
            comp_module.label = label_base + modifier["mod_key"]

        comp_module.label = comp_module.label + "_comparison"
        self.label = comp_module.label

        minarg_tcon = np.argmin(comp_module.time_const_comparison)
        minarg_struc = np.argmin(comp_module.structure_comparison)

        if type(modifier["mod_key"]) is tuple:
            logger.info(f"For {comp_module.label}:")

            logger.info(
                f"Minimum for time const: {comp_module.time_const_comparison[minarg_tcon]}"
            )
            logger.info(
                f"Minimum for structure function: {comp_module.structure_comparison[minarg_struc]}"
            )
            logger.info(
                f"Minimum for total resistance difference: {comp_module.total_resist_diff[minarg_struc]}"
            )

        else:
            logger.info(f"For {comp_module.label}:")

            logger.info(
                f"Minimum for time const: {comp_module.time_const_comparison[minarg_tcon]}"
            )
            logger.info(
                f"Minimum for structure function: {comp_module.structure_comparison[minarg_struc]}"
            )
            logger.info(
                f"Minimum for total resistance difference: {comp_module.total_resist_diff[minarg_struc]}"
            )

        comp_module.data_handlers.append("comparison")

        return comp_module

    def temperature_prediction_module(self, parameters):

        for key, value in parameters.items():
            self.parameters[key] = value

        module = self._optimization_module({}, mode="from_data")

        self.parameters["infile"] = self.parameters["infile_3"]
        self.parameters["infile_2"] = self.parameters["infile_4"]
        self.parameters["av_range"] = self.parameters["av_range_2"]
        self.parameters["label"] = self.parameters["label_2"]

        self.parameters["power_step"] = 1.0
        module_2 = self._standard_module({"only_make_z": True})

        module_2.reference_impedance = module.theo_impedance
        module_2.reference_time = np.exp(module.theo_log_time)

        module_2.reference_impulse_response = np.gradient(
            module_2.reference_impedance, module_2.reference_time
        )

        module_2.actual_impedance = -module_2.impedance
        module_2.actual_time = np.exp(module_2.log_time)

        t_min = -module_2.time[-1] * 1.5
        t_max = module_2.time[-1] * 1.5

        lin_t_number = int((t_max - t_min) / self.parameters["lin_sampling_rate"])

        assert lin_t_number < 1e8

        module_2.lin_time, dt = np.linspace(t_min, t_max, lin_t_number, retstep=True)

        data = np.loadtxt(self.parameters["infile_powersteps"])

        module_2.power_t = data[:, 0]
        module_2.power_function = data[:, 1]  # / data[-1,1]

        logger.info("Interpolating power function and impulse response")

        module_2.power_function_int = np.interp(
            module_2.lin_time, module_2.power_t, module_2.power_function, left=0.0
        )
        module_2.impulse_response_int = np.interp(
            module_2.lin_time,
            module_2.reference_time,
            module_2.reference_impulse_response,
            left=0.0,
            right=0.0,
        )

        logger.info("Interpolation done")

        logger.info("Starting convolution")

        module_2.predicted_impedance = (
            np.convolve(
                module_2.power_function_int, module_2.impulse_response_int, mode="full"
            )
            * dt
        )

        module_2.predicted_impedance = module_2.predicted_impedance[
            lin_t_number // 2 : -(lin_t_number // 2 - 1)
        ]

        logger.info("Convolution done")

        area_interp = np.trapz(module_2.impulse_response_int, x=module_2.lin_time)
        area_org = np.trapz(
            module_2.reference_impulse_response, x=module_2.reference_time
        )

        logger.info(f"Original area: {area_org}")
        logger.info(f"Interpolated area: {area_interp}")

        module.data_handlers.append("prediction")
